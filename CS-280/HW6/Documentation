1.1 Draw a heap

Given array => 80, 30, 35, 13, 10, 25, 3, 15

Given Tree =>
         80
        /  \
      30    35
     /  \   / \
   13   10 25  3
  /  \
15   30


1.2 Heapify

Initialize the array: A = [5, 10, 3, 2, 5, 80, 15, 72]
Call the buildHeap function: buildHeap(A)
Step 2 will execute the following steps:

The loop in buildHeap will run for x = 2, 1, 0
In the first iteration, maxHeapify(A, 2) will be called.
This will result in the array A = [5, 10, 80, 2, 5, 3, 15, 72]

In the second iteration, maxHeapify(A, 1) will be called. 
This will result in the array A = [5, 72, 80, 2, 5, 3, 15, 10]

In the third and final iteration, maxHeapify(A, 0) will be called. 
This will result in the array A = [80, 72, 15, 2, 5, 3, 5, 10]

The resulting array [80, 72, 15, 2, 5, 3, 5, 10] represents a valid max-heap, 
where the largest element (80) is at the root and each node is larger than its children.


1.3 The why of Heaps
One situation where a heap would be preferable to a red-black tree is when we need to maintain a priority queue, and the priority of elements changes frequently. In a priority queue, we want to quickly access the element with the highest or lowest priority, and heaps provide efficient O(1) access to the highest or lowest element. Heap operations such as insertion and deletion are also faster than red-black tree operations since they only involve swapping elements at specific indices and then restoring the heap property, which has a time complexity of O(log n) for a heap. Red-black trees, on the other hand, require balancing operations to maintain the balanced tree property after insertion or deletion, which can take longer than heap operations and have a time complexity of O(log n).

One situation where a red-black tree would be preferable to a heap is when we need to perform frequent search operations on the data structure. Red-black trees provide efficient search operations since they are balanced and guarantee a maximum height of O(log n), resulting in a time complexity of O(log n) for search operations. In contrast, heaps do not guarantee any specific ordering of elements beyond the heap property, making search operations inefficient, with a time complexity of O(n) in the worst case. Therefore, if we need to perform many search operations, a red-black tree would be a better choice than a heap. Additionally, red-black trees support more complex operations such as range queries and iteration in sorted order, which can be useful in many applications.


